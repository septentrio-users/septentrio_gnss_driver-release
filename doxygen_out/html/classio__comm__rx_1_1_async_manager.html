<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSaic: io_comm_rx::AsyncManager&lt; StreamT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSaic
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceio__comm__rx.html">io_comm_rx</a></li><li class="navelem"><a class="el" href="classio__comm__rx_1_1_async_manager.html">AsyncManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">io_comm_rx::AsyncManager&lt; StreamT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the central interface between ROSaic and the Rx(s), managing I/O operations such as reading messages and sending commands..  
 <a href="classio__comm__rx_1_1_async_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for io_comm_rx::AsyncManager&lt; StreamT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager__inherit__graph.png" border="0" usemap="#io__comm__rx_1_1_async_manager_3_01_stream_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="io__comm__rx_1_1_async_manager_3_01_stream_t_01_4_inherit__map" id="io__comm__rx_1_1_async_manager_3_01_stream_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_manager.html" title="Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike..." alt="" coords="24,5,175,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for io_comm_rx::AsyncManager&lt; StreamT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager__coll__graph.png" border="0" usemap="#io__comm__rx_1_1_async_manager_3_01_stream_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="io__comm__rx_1_1_async_manager_3_01_stream_t_01_4_coll__map" id="io__comm__rx_1_1_async_manager_3_01_stream_t_01_4_coll__map">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_manager.html" title="Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike..." alt="" coords="175,5,326,32"/>
<area shape="rect" id="node7" href="class_circular_buffer.html" title="Class for creating, writing to and reading from a circular buffer. " alt="" coords="199,272,302,299"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad06b8889141682af1a6279936326d964"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#ad06b8889141682af1a6279936326d964">AsyncManager</a> (boost::shared_ptr&lt; StreamT &gt; stream, boost::shared_ptr&lt; boost::asio::io_service &gt; io_service, std::size_t buffer_size=8192)</td></tr>
<tr class="memdesc:ad06b8889141682af1a6279936326d964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor.  <a href="#ad06b8889141682af1a6279936326d964">More...</a><br /></td></tr>
<tr class="separator:ad06b8889141682af1a6279936326d964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c6b1e3ba985085f3957d5697976793"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a79c6b1e3ba985085f3957d5697976793">~AsyncManager</a> ()</td></tr>
<tr class="separator:a79c6b1e3ba985085f3957d5697976793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add27deeeb6f3ca46429cb4784ab02965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#add27deeeb6f3ca46429cb4784ab02965">setCallback</a> (const <a class="el" href="classio__comm__rx_1_1_manager.html#a029aa66b239f8cee73fcae010ac5c980">Callback</a> &amp;callback)</td></tr>
<tr class="memdesc:add27deeeb6f3ca46429cb4784ab02965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback function.  <a href="#add27deeeb6f3ca46429cb4784ab02965">More...</a><br /></td></tr>
<tr class="separator:add27deeeb6f3ca46429cb4784ab02965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2935508cf711725e8cf8b5d79a00a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7">wait</a> (uint16_t *count)</td></tr>
<tr class="memdesc:a9c2935508cf711725e8cf8b5d79a00a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived.  <a href="#a9c2935508cf711725e8cf8b5d79a00a7">More...</a><br /></td></tr>
<tr class="separator:a9c2935508cf711725e8cf8b5d79a00a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa916a81db2b67c3fc2ff33dc419474df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#aa916a81db2b67c3fc2ff33dc419474df">send</a> (std::string cmd, std::size_t size)</td></tr>
<tr class="memdesc:aa916a81db2b67c3fc2ff33dc419474df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends commands via the I/O stream.  <a href="#aa916a81db2b67c3fc2ff33dc419474df">More...</a><br /></td></tr>
<tr class="separator:aa916a81db2b67c3fc2ff33dc419474df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f973504dd9b8e576e294cccce953a60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a7f973504dd9b8e576e294cccce953a60">isOpen</a> () const</td></tr>
<tr class="memdesc:a7f973504dd9b8e576e294cccce953a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the connection is open.  <a href="#a7f973504dd9b8e576e294cccce953a60">More...</a><br /></td></tr>
<tr class="separator:a7f973504dd9b8e576e294cccce953a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classio__comm__rx_1_1_manager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classio__comm__rx_1_1_manager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classio__comm__rx_1_1_manager.html">io_comm_rx::Manager</a></td></tr>
<tr class="memitem:a12ff8e5d6efe7a19ff0d5589d47f2d17 inherit pub_methods_classio__comm__rx_1_1_manager"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_manager.html#a12ff8e5d6efe7a19ff0d5589d47f2d17">~Manager</a> ()</td></tr>
<tr class="separator:a12ff8e5d6efe7a19ff0d5589d47f2d17 inherit pub_methods_classio__comm__rx_1_1_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab1111154be47a210fa8d22500701f5ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#ab1111154be47a210fa8d22500701f5ad">read</a> ()</td></tr>
<tr class="memdesc:ab1111154be47a210fa8d22500701f5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read_some_handler.  <a href="#ab1111154be47a210fa8d22500701f5ad">More...</a><br /></td></tr>
<tr class="separator:ab1111154be47a210fa8d22500701f5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1fa56a49f408d7d708b447bb356b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a3b1fa56a49f408d7d708b447bb356b92">asyncReadSomeHandler</a> (const boost::system::error_code &amp;error, std::size_t bytes_transferred)</td></tr>
<tr class="memdesc:a3b1fa56a49f408d7d708b447bb356b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for async_read_some (Boost library)..  <a href="#a3b1fa56a49f408d7d708b447bb356b92">More...</a><br /></td></tr>
<tr class="separator:a3b1fa56a49f408d7d708b447bb356b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b9a040f84fb4a4e173cc53b85a4a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a01b9a040f84fb4a4e173cc53b85a4a22">write</a> (std::string cmd, std::size_t size)</td></tr>
<tr class="memdesc:a01b9a040f84fb4a4e173cc53b85a4a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends command "cmd" to the Rx.  <a href="#a01b9a040f84fb4a4e173cc53b85a4a22">More...</a><br /></td></tr>
<tr class="separator:a01b9a040f84fb4a4e173cc53b85a4a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83036856524fbc3b48dc5588199503f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a83036856524fbc3b48dc5588199503f3">close</a> ()</td></tr>
<tr class="memdesc:a83036856524fbc3b48dc5588199503f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes stream "stream_".  <a href="#a83036856524fbc3b48dc5588199503f3">More...</a><br /></td></tr>
<tr class="separator:a83036856524fbc3b48dc5588199503f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c366d486f4ef8153406aa5af7c825a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a06c366d486f4ef8153406aa5af7c825a">tryParsing</a> ()</td></tr>
<tr class="memdesc:a06c366d486f4ef8153406aa5af7c825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries parsing SBF/NMEA whenever the boolean class variable "try_parsing" is true.  <a href="#a06c366d486f4ef8153406aa5af7c825a">More...</a><br /></td></tr>
<tr class="separator:a06c366d486f4ef8153406aa5af7c825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe4c5680f2e629a6d5b577578dca88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a74fe4c5680f2e629a6d5b577578dca88">callAsyncWait</a> (uint16_t *count)</td></tr>
<tr class="memdesc:a74fe4c5680f2e629a6d5b577578dca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the ROS_INFO throwing (if no incoming message)  <a href="#a74fe4c5680f2e629a6d5b577578dca88">More...</a><br /></td></tr>
<tr class="separator:a74fe4c5680f2e629a6d5b577578dca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a39e1c574e60972026401cb9cea9e2b3b"><td class="memItemLeft" align="right" valign="top">boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a39e1c574e60972026401cb9cea9e2b3b">parse_mutex_</a></td></tr>
<tr class="memdesc:a39e1c574e60972026401cb9cea9e2b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to control changes of class variable "try_parsing".  <a href="#a39e1c574e60972026401cb9cea9e2b3b">More...</a><br /></td></tr>
<tr class="separator:a39e1c574e60972026401cb9cea9e2b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb589f6258bbb2430a32bc3178635a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">try_parsing_</a></td></tr>
<tr class="memdesc:a95fb589f6258bbb2430a32bc3178635a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines when the <a class="el" href="classio__comm__rx_1_1_async_manager.html#a06c366d486f4ef8153406aa5af7c825a" title="Tries parsing SBF/NMEA whenever the boolean class variable &quot;try_parsing&quot; is true. ...">tryParsing()</a> method will attempt parsing SBF/NMEA.  <a href="#a95fb589f6258bbb2430a32bc3178635a">More...</a><br /></td></tr>
<tr class="separator:a95fb589f6258bbb2430a32bc3178635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240308ada2048ab442fe0f57f57e4563"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">allow_writing_</a></td></tr>
<tr class="memdesc:a240308ada2048ab442fe0f57f57e4563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines when the <a class="el" href="classio__comm__rx_1_1_async_manager.html#a3b1fa56a49f408d7d708b447bb356b92" title="Handler for async_read_some (Boost library).. ">asyncReadSomeHandler()</a> method should write SBF/NMEA into the circular buffer.  <a href="#a240308ada2048ab442fe0f57f57e4563">More...</a><br /></td></tr>
<tr class="separator:a240308ada2048ab442fe0f57f57e4563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd9a9f61c0bbcd0d388c14a0565a320"><td class="memItemLeft" align="right" valign="top">boost::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">parsing_condition_</a></td></tr>
<tr class="memdesc:a4bd9a9f61c0bbcd0d388c14a0565a320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable complementing "parse_mutex".  <a href="#a4bd9a9f61c0bbcd0d388c14a0565a320">More...</a><br /></td></tr>
<tr class="separator:a4bd9a9f61c0bbcd0d388c14a0565a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb3f8f003366292da374f48a4a8c74f"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; StreamT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">stream_</a></td></tr>
<tr class="memdesc:a9cb3f8f003366292da374f48a4a8c74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream, represents either serial or TCP/IP connection.  <a href="#a9cb3f8f003366292da374f48a4a8c74f">More...</a><br /></td></tr>
<tr class="separator:a9cb3f8f003366292da374f48a4a8c74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908ef31c7d47b0c7a2ebf0da81bf159f"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_service_</a></td></tr>
<tr class="memdesc:a908ef31c7d47b0c7a2ebf0da81bf159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">io_context object  <a href="#a908ef31c7d47b0c7a2ebf0da81bf159f">More...</a><br /></td></tr>
<tr class="separator:a908ef31c7d47b0c7a2ebf0da81bf159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12df1fd87f1b4b00119b0a0b0a2e9fb8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a></td></tr>
<tr class="memdesc:a12df1fd87f1b4b00119b0a0b0a2e9fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer for async_read_some() to read continuous SBF/NMEA stream.  <a href="#a12df1fd87f1b4b00119b0a0b0a2e9fb8">More...</a><br /></td></tr>
<tr class="separator:a12df1fd87f1b4b00119b0a0b0a2e9fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc3ddfac469f0a9e5d36cd5f0e42ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_circular_buffer.html">CircularBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">circular_buffer_</a></td></tr>
<tr class="memdesc:a0dc3ddfac469f0a9e5d36cd5f0e42ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer to avoid unsuccessful SBF/NMEA parsing due to incomplete messages.  <a href="#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">More...</a><br /></td></tr>
<tr class="separator:a0dc3ddfac469f0a9e5d36cd5f0e42ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41be2722ecb9acf52af76d2f93fac67e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">to_be_parsed_</a></td></tr>
<tr class="memdesc:a41be2722ecb9acf52af76d2f93fac67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory location where read_callback_ will start reading unless part of SBF/NMEA had to be appended before.  <a href="#a41be2722ecb9acf52af76d2f93fac67e">More...</a><br /></td></tr>
<tr class="separator:a41be2722ecb9acf52af76d2f93fac67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51886601f6fd665cac7bdc76fdd6181"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; boost::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">async_background_thread_</a></td></tr>
<tr class="memdesc:ad51886601f6fd665cac7bdc76fdd6181"><td class="mdescLeft">&#160;</td><td class="mdescRight">New thread for receiving incoming messages.  <a href="#ad51886601f6fd665cac7bdc76fdd6181">More...</a><br /></td></tr>
<tr class="separator:ad51886601f6fd665cac7bdc76fdd6181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde94fe262cc75edd105d6df1805f51f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classio__comm__rx_1_1_manager.html#a029aa66b239f8cee73fcae010ac5c980">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">read_callback_</a></td></tr>
<tr class="memdesc:adde94fe262cc75edd105d6df1805f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to be called once message arrives.  <a href="#adde94fe262cc75edd105d6df1805f51f">More...</a><br /></td></tr>
<tr class="separator:adde94fe262cc75edd105d6df1805f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d850fe28cf7e7c7c7b4b2a48943afc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">stopping_</a></td></tr>
<tr class="memdesc:a3d850fe28cf7e7c7c7b4b2a48943afc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not we want to sever the connection to the Rx.  <a href="#a3d850fe28cf7e7c7c7b4b2a48943afc9">More...</a><br /></td></tr>
<tr class="separator:a3d850fe28cf7e7c7c7b4b2a48943afc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b50fd4aa9210ebf0bcbf51686fd7444"><td class="memItemLeft" align="right" valign="top">const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a></td></tr>
<tr class="memdesc:a6b50fd4aa9210ebf0bcbf51686fd7444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of in_ buffers.  <a href="#a6b50fd4aa9210ebf0bcbf51686fd7444">More...</a><br /></td></tr>
<tr class="separator:a6b50fd4aa9210ebf0bcbf51686fd7444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e55c30047a31ca0186a3b3329363db"><td class="memItemLeft" align="right" valign="top">boost::asio::deadline_timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">timer_</a></td></tr>
<tr class="memdesc:ad7e55c30047a31ca0186a3b3329363db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost timer for throwing ROS_INFO message once timed out due to lack of incoming messages.  <a href="#ad7e55c30047a31ca0186a3b3329363db">More...</a><br /></td></tr>
<tr class="separator:ad7e55c30047a31ca0186a3b3329363db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4659656978af102fc9c3cacc446d4871"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">count_max_</a></td></tr>
<tr class="memdesc:a4659656978af102fc9c3cacc446d4871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of seconds before ROS_INFO message is thrown (if no incoming message)  <a href="#a4659656978af102fc9c3cacc446d4871">More...</a><br /></td></tr>
<tr class="separator:a4659656978af102fc9c3cacc446d4871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24276a6240a5250a9204a55a659b86ac"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">do_read_count_</a></td></tr>
<tr class="memdesc:a24276a6240a5250a9204a55a659b86ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times the DoRead() method has been called (only counts initially)  <a href="#a24276a6240a5250a9204a55a659b86ac">More...</a><br /></td></tr>
<tr class="separator:a24276a6240a5250a9204a55a659b86ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classio__comm__rx_1_1_manager"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classio__comm__rx_1_1_manager')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classio__comm__rx_1_1_manager.html">io_comm_rx::Manager</a></td></tr>
<tr class="memitem:a029aa66b239f8cee73fcae010ac5c980 inherit pub_types_classio__comm__rx_1_1_manager"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; void(const uint8_t *, std::size_t &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__rx_1_1_manager.html#a029aa66b239f8cee73fcae010ac5c980">Callback</a></td></tr>
<tr class="separator:a029aa66b239f8cee73fcae010ac5c980 inherit pub_types_classio__comm__rx_1_1_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StreamT&gt;<br />
class io_comm_rx::AsyncManager&lt; StreamT &gt;</h3>

<p>This is the central interface between ROSaic and the Rx(s), managing I/O operations such as reading messages and sending commands.. </p>
<p>StreamT is either boost::asio::serial_port or boost::asio::tcp::ip </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00112">112</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad06b8889141682af1a6279936326d964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06b8889141682af1a6279936326d964">&#9670;&nbsp;</a></span>AsyncManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="classio__comm__rx_1_1_async_manager.html">AsyncManager</a> </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; StreamT &gt;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>8192</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Whether TCP/IP or serial communication, either boost::asio::serial_port or boost::asio::tcp::ip </td></tr>
    <tr><td class="paramname">io_service</td><td>The io_context object. The io_context represents your program's link to the operating system's I/O services. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00296">296</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00181">io_comm_rx::AsyncManager&lt; StreamT &gt;::async_background_thread_</a>, <a class="el" href="async__manager_8hpp_source.html#l00190">io_comm_rx::AsyncManager&lt; StreamT &gt;::buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00290">io_comm_rx::AsyncManager&lt; StreamT &gt;::callAsyncWait()</a>, <a class="el" href="async__manager_8hpp_source.html#l00172">io_comm_rx::AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00169">io_comm_rx::AsyncManager&lt; StreamT &gt;::io_service_</a>, <a class="el" href="async__manager_8hpp_source.html#l00166">io_comm_rx::AsyncManager&lt; StreamT &gt;::stream_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00207">io_comm_rx::AsyncManager&lt; StreamT &gt;::tryParsing()</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                   : <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">timer_</a>(*(io_service.get()), boost::posix_time::seconds(1)), </div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">stopping_</a>(<span class="keyword">false</span>), <a class="code" href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">try_parsing_</a>(<span class="keyword">false</span>), <a class="code" href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">allow_writing_</a>(<span class="keyword">true</span>), <a class="code" href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">do_read_count_</a>(0), <a class="code" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a>(buffer_size), </div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">count_max_</a>(6), <a class="code" href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">circular_buffer_</a>(buffer_size) </div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            <span class="comment">// Since buffer_size = 8912 in declaration, no need in definition any more (even yields error message, </span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="comment">// since &quot;overwrite&quot;).</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Setting the private stream variable of the AsyncManager instance.&quot;</span>);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">stream_</a> = stream;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_service_</a> = io_service;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a>.resize(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a>);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;         </div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#ab1111154be47a210fa8d22500701f5ad">AsyncManager&lt;StreamT&gt;::read</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="comment">// This function is used to ask the io_service to execute the given handler, but without allowing the io_service</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="comment">// to call the handler from inside this function. The function signature of the handler must be: void handler(); </span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="comment">// The io_service guarantees that the handler (given as parameter) will only be called in a thread in which the </span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="comment">// run(), run_one(), poll() or poll_one() member functions is currently being invoked. So the fundamental </span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="comment">// difference is that dispatch will execute the work right away if it can and queue it otherwise while post queues the work no matter what.</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">async_background_thread_</a>.reset(<span class="keyword">new</span> boost::thread(boost::bind(&amp;boost::asio::io_service::run, <a class="code" href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_service_</a>))); </div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="comment">// Note that io_service_ is already pointer, hence need dereferencing operator &amp; (ampersand). If the value of the </span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="comment">// pointer for the current thread is changed using reset(), then the previous value is destroyed by calling the </span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="comment">// cleanup routine. Alternatively, the stored value can be reset to NULL and the prior value returned by calling</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="comment">// the release() member function, allowing the application to take back responsibility for destroying the object. </span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        uint16_t count = 0;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        boost::thread(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#a74fe4c5680f2e629a6d5b577578dca88">AsyncManager::callAsyncWait</a>, <span class="keyword">this</span>, &amp;count));</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        </div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Launching tryParsing() thread..&quot;</span>);</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        boost::thread(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#a06c366d486f4ef8153406aa5af7c825a">AsyncManager::tryParsing</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    }   <span class="comment">// Calls std::terminate() on thread just created</span></div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ab1111154be47a210fa8d22500701f5ad"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ab1111154be47a210fa8d22500701f5ad">io_comm_rx::AsyncManager::read</a></div><div class="ttdeci">void read()</div><div class="ttdoc">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00334">async_manager.hpp:334</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a24276a6240a5250a9204a55a659b86ac"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">io_comm_rx::AsyncManager::do_read_count_</a></div><div class="ttdeci">uint16_t do_read_count_</div><div class="ttdoc">Number of times the DoRead() method has been called (only counts initially) </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00202">async_manager.hpp:202</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ad7e55c30047a31ca0186a3b3329363db"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">io_comm_rx::AsyncManager::timer_</a></div><div class="ttdeci">boost::asio::deadline_timer timer_</div><div class="ttdoc">Boost timer for throwing ROS_INFO message once timed out due to lack of incoming messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00193">async_manager.hpp:193</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a4659656978af102fc9c3cacc446d4871"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">io_comm_rx::AsyncManager::count_max_</a></div><div class="ttdeci">const uint16_t count_max_</div><div class="ttdoc">Number of seconds before ROS_INFO message is thrown (if no incoming message) </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00196">async_manager.hpp:196</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a6b50fd4aa9210ebf0bcbf51686fd7444"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">io_comm_rx::AsyncManager::buffer_size_</a></div><div class="ttdeci">const std::size_t buffer_size_</div><div class="ttdoc">Size of in_ buffers. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00190">async_manager.hpp:190</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a0dc3ddfac469f0a9e5d36cd5f0e42ba7"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">io_comm_rx::AsyncManager::circular_buffer_</a></div><div class="ttdeci">CircularBuffer circular_buffer_</div><div class="ttdoc">Circular buffer to avoid unsuccessful SBF/NMEA parsing due to incomplete messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00175">async_manager.hpp:175</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a908ef31c7d47b0c7a2ebf0da81bf159f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_comm_rx::AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdoc">io_context object </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00169">async_manager.hpp:169</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a12df1fd87f1b4b00119b0a0b0a2e9fb8"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">io_comm_rx::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdoc">Buffer for async_read_some() to read continuous SBF/NMEA stream. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00172">async_manager.hpp:172</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ad51886601f6fd665cac7bdc76fdd6181"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">io_comm_rx::AsyncManager::async_background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; async_background_thread_</div><div class="ttdoc">New thread for receiving incoming messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00181">async_manager.hpp:181</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9cb3f8f003366292da374f48a4a8c74f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">io_comm_rx::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00166">async_manager.hpp:166</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a74fe4c5680f2e629a6d5b577578dca88"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a74fe4c5680f2e629a6d5b577578dca88">io_comm_rx::AsyncManager::callAsyncWait</a></div><div class="ttdeci">void callAsyncWait(uint16_t *count)</div><div class="ttdoc">Handles the ROS_INFO throwing (if no incoming message) </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00290">async_manager.hpp:290</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a240308ada2048ab442fe0f57f57e4563"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">io_comm_rx::AsyncManager::allow_writing_</a></div><div class="ttdeci">bool allow_writing_</div><div class="ttdoc">Determines when the asyncReadSomeHandler() method should write SBF/NMEA into the circular buffer...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00160">async_manager.hpp:160</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a95fb589f6258bbb2430a32bc3178635a"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">io_comm_rx::AsyncManager::try_parsing_</a></div><div class="ttdeci">bool try_parsing_</div><div class="ttdoc">Determines when the tryParsing() method will attempt parsing SBF/NMEA. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00157">async_manager.hpp:157</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a06c366d486f4ef8153406aa5af7c825a"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a06c366d486f4ef8153406aa5af7c825a">io_comm_rx::AsyncManager::tryParsing</a></div><div class="ttdeci">void tryParsing()</div><div class="ttdoc">Tries parsing SBF/NMEA whenever the boolean class variable &quot;try_parsing&quot; is true. ...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00207">async_manager.hpp:207</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a3d850fe28cf7e7c7c7b4b2a48943afc9"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">io_comm_rx::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdoc">Whether or not we want to sever the connection to the Rx. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00187">async_manager.hpp:187</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_ad06b8889141682af1a6279936326d964_cgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_ad06b8889141682af1a6279936326d964_cgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_ad06b8889141682af1a6279936326d964_cgraph" id="classio__comm__rx_1_1_async_manager_ad06b8889141682af1a6279936326d964_cgraph">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_async_manager.html#a74fe4c5680f2e629a6d5b577578dca88" title="Handles the ROS_INFO throwing (if no incoming message) " alt="" coords="241,5,429,47"/>
<area shape="rect" id="node4" href="classio__comm__rx_1_1_async_manager.html#a06c366d486f4ef8153406aa5af7c825a" title="Tries parsing SBF/NMEA whenever the boolean class variable &quot;try_parsing&quot; is true. ..." alt="" coords="241,71,429,112"/>
<area shape="rect" id="node3" href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7" title="Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived..." alt="" coords="477,5,665,47"/>
</map>
</div>

</div>
</div>
<a id="a79c6b1e3ba985085f3957d5697976793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c6b1e3ba985085f3957d5697976793">&#9670;&nbsp;</a></span>~AsyncManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::~<a class="el" href="classio__comm__rx_1_1_async_manager.html">AsyncManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00328">328</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00181">io_comm_rx::AsyncManager&lt; StreamT &gt;::async_background_thread_</a>.</p>
<div class="fragment"><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    {</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">async_background_thread_</a>-&gt;join(); </div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ad51886601f6fd665cac7bdc76fdd6181"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">io_comm_rx::AsyncManager::async_background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; async_background_thread_</div><div class="ttdoc">New thread for receiving incoming messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00181">async_manager.hpp:181</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b1fa56a49f408d7d708b447bb356b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1fa56a49f408d7d708b447bb356b92">&#9670;&nbsp;</a></span>asyncReadSomeHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::asyncReadSomeHandler </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes_transferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for async_read_some (Boost library).. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00348">348</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00160">io_comm_rx::AsyncManager&lt; StreamT &gt;::allow_writing_</a>, <a class="el" href="async__manager_8hpp_source.html#l00190">io_comm_rx::AsyncManager&lt; StreamT &gt;::buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00175">io_comm_rx::AsyncManager&lt; StreamT &gt;::circular_buffer_</a>, <a class="el" href="async__manager_8hpp_source.html#l00172">io_comm_rx::AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00169">io_comm_rx::AsyncManager&lt; StreamT &gt;::io_service_</a>, <a class="el" href="async__manager_8hpp_source.html#l00154">io_comm_rx::AsyncManager&lt; StreamT &gt;::parse_mutex_</a>, <a class="el" href="async__manager_8hpp_source.html#l00163">io_comm_rx::AsyncManager&lt; StreamT &gt;::parsing_condition_</a>, <a class="el" href="async__manager_8hpp_source.html#l00184">io_comm_rx::AsyncManager&lt; StreamT &gt;::read_callback_</a>, <a class="el" href="async__manager_8hpp_source.html#l00187">io_comm_rx::AsyncManager&lt; StreamT &gt;::stopping_</a>, <a class="el" href="async__manager_8hpp_source.html#l00157">io_comm_rx::AsyncManager&lt; StreamT &gt;::try_parsing_</a>, and <a class="el" href="circular__buffer_8cpp_source.html#l00051">CircularBuffer::write()</a>.</p>
<div class="fragment"><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">if</span> (error) </div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        {</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            ROS_ERROR(<span class="stringliteral">&quot;Rx ASIO input buffer read error: %s, %li&quot;</span>, error.message().c_str(), bytes_transferred); </div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        } </div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_transferred &gt; 0) </div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        { </div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">read_callback_</a>) <span class="comment">//Will be false in InitializeSerial (first call) since read_callback_ not added yet..</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            {</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                boost::mutex::scoped_lock lock(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a39e1c574e60972026401cb9cea9e2b3b">parse_mutex_</a>);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">parsing_condition_</a>.wait(lock, [<span class="keyword">this</span>](){<span class="keywordflow">return</span> <a class="code" href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">allow_writing_</a>;});</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">circular_buffer_</a>.<a class="code" href="class_circular_buffer.html#aaeabea80655d80bfe4ef8b6ad91da2bd">write</a>(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a>.data(), bytes_transferred);</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">allow_writing_</a> = <span class="keyword">false</span>;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">try_parsing_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                lock.unlock();</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">parsing_condition_</a>.notify_one();</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                std::vector&lt;uint8_t&gt; empty;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a> = empty;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a>.resize(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a>);</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;            }</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        }</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;     </div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">stopping_</a>)</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#ab1111154be47a210fa8d22500701f5ad">AsyncManager&lt;StreamT&gt;::read</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ab1111154be47a210fa8d22500701f5ad"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ab1111154be47a210fa8d22500701f5ad">io_comm_rx::AsyncManager::read</a></div><div class="ttdeci">void read()</div><div class="ttdoc">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00334">async_manager.hpp:334</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a6b50fd4aa9210ebf0bcbf51686fd7444"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">io_comm_rx::AsyncManager::buffer_size_</a></div><div class="ttdeci">const std::size_t buffer_size_</div><div class="ttdoc">Size of in_ buffers. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00190">async_manager.hpp:190</a></div></div>
<div class="ttc" id="class_circular_buffer_html_aaeabea80655d80bfe4ef8b6ad91da2bd"><div class="ttname"><a href="class_circular_buffer.html#aaeabea80655d80bfe4ef8b6ad91da2bd">CircularBuffer::write</a></div><div class="ttdeci">std::size_t write(const uint8_t *data, std::size_t bytes)</div><div class="ttdoc">Returns number of bytes written. </div><div class="ttdef"><b>Definition:</b> <a href="circular__buffer_8cpp_source.html#l00051">circular_buffer.cpp:51</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a0dc3ddfac469f0a9e5d36cd5f0e42ba7"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">io_comm_rx::AsyncManager::circular_buffer_</a></div><div class="ttdeci">CircularBuffer circular_buffer_</div><div class="ttdoc">Circular buffer to avoid unsuccessful SBF/NMEA parsing due to incomplete messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00175">async_manager.hpp:175</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a908ef31c7d47b0c7a2ebf0da81bf159f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_comm_rx::AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdoc">io_context object </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00169">async_manager.hpp:169</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a12df1fd87f1b4b00119b0a0b0a2e9fb8"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">io_comm_rx::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdoc">Buffer for async_read_some() to read continuous SBF/NMEA stream. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00172">async_manager.hpp:172</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a4bd9a9f61c0bbcd0d388c14a0565a320"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">io_comm_rx::AsyncManager::parsing_condition_</a></div><div class="ttdeci">boost::condition_variable parsing_condition_</div><div class="ttdoc">Condition variable complementing &quot;parse_mutex&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00163">async_manager.hpp:163</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_adde94fe262cc75edd105d6df1805f51f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">io_comm_rx::AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdoc">Callback to be called once message arrives. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00184">async_manager.hpp:184</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a240308ada2048ab442fe0f57f57e4563"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">io_comm_rx::AsyncManager::allow_writing_</a></div><div class="ttdeci">bool allow_writing_</div><div class="ttdoc">Determines when the asyncReadSomeHandler() method should write SBF/NMEA into the circular buffer...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00160">async_manager.hpp:160</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a39e1c574e60972026401cb9cea9e2b3b"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a39e1c574e60972026401cb9cea9e2b3b">io_comm_rx::AsyncManager::parse_mutex_</a></div><div class="ttdeci">boost::mutex parse_mutex_</div><div class="ttdoc">Mutex to control changes of class variable &quot;try_parsing&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00154">async_manager.hpp:154</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a95fb589f6258bbb2430a32bc3178635a"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">io_comm_rx::AsyncManager::try_parsing_</a></div><div class="ttdeci">bool try_parsing_</div><div class="ttdoc">Determines when the tryParsing() method will attempt parsing SBF/NMEA. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00157">async_manager.hpp:157</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a3d850fe28cf7e7c7c7b4b2a48943afc9"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">io_comm_rx::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdoc">Whether or not we want to sever the connection to the Rx. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00187">async_manager.hpp:187</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_a3b1fa56a49f408d7d708b447bb356b92_cgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_a3b1fa56a49f408d7d708b447bb356b92_cgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_a3b1fa56a49f408d7d708b447bb356b92_cgraph" id="classio__comm__rx_1_1_async_manager_a3b1fa56a49f408d7d708b447bb356b92_cgraph">
<area shape="rect" id="node2" href="class_circular_buffer.html#aaeabea80655d80bfe4ef8b6ad91da2bd" title="Returns number of bytes written. " alt="" coords="241,13,380,39"/>
<area shape="rect" id="node3" href="class_circular_buffer.html#a453971561ff89049ab87c9fe801efb17" title="Returns capacity_. " alt="" coords="428,13,587,39"/>
<area shape="rect" id="node4" href="class_circular_buffer.html#ac0d39c8f590584dbb8e98c320e169c88" title="Returns number of bytes read. " alt="" coords="635,13,769,39"/>
</map>
</div>

</div>
</div>
<a id="a74fe4c5680f2e629a6d5b577578dca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe4c5680f2e629a6d5b577578dca88">&#9670;&nbsp;</a></span>callAsyncWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::callAsyncWait </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the ROS_INFO throwing (if no incoming message) </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00290">290</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00389">io_comm_rx::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>
<div class="fragment"><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    {</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">timer_</a>.async_wait(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7">AsyncManager::wait</a>, <span class="keyword">this</span>, count));</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ad7e55c30047a31ca0186a3b3329363db"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">io_comm_rx::AsyncManager::timer_</a></div><div class="ttdeci">boost::asio::deadline_timer timer_</div><div class="ttdoc">Boost timer for throwing ROS_INFO message once timed out due to lack of incoming messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00193">async_manager.hpp:193</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9c2935508cf711725e8cf8b5d79a00a7"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7">io_comm_rx::AsyncManager::wait</a></div><div class="ttdeci">void wait(uint16_t *count)</div><div class="ttdoc">Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00389">async_manager.hpp:389</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_cgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_cgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_cgraph" id="classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_cgraph">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7" title="Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived..." alt="" coords="241,5,429,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_icgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_icgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_icgraph" id="classio__comm__rx_1_1_async_manager_a74fe4c5680f2e629a6d5b577578dca88_icgraph">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_async_manager.html#ad06b8889141682af1a6279936326d964" title="Class constructor. " alt="" coords="241,5,429,47"/>
</map>
</div>

</div>
</div>
<a id="a83036856524fbc3b48dc5588199503f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83036856524fbc3b48dc5588199503f3">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes stream "stream_". </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00377">377</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00187">io_comm_rx::AsyncManager&lt; StreamT &gt;::stopping_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00166">io_comm_rx::AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">stopping_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        boost::system::error_code error;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">stream_</a>-&gt;close(error); </div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordflow">if</span>(error)</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        {</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            ROS_ERROR_STREAM(<span class="stringliteral">&quot;Error while closing the AsyncManager: &quot;</span> &lt;&lt; error.message().c_str());</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        }</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9cb3f8f003366292da374f48a4a8c74f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">io_comm_rx::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00166">async_manager.hpp:166</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a3d850fe28cf7e7c7c7b4b2a48943afc9"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a3d850fe28cf7e7c7c7b4b2a48943afc9">io_comm_rx::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdoc">Whether or not we want to sever the connection to the Rx. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00187">async_manager.hpp:187</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f973504dd9b8e576e294cccce953a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f973504dd9b8e576e294cccce953a60">&#9670;&nbsp;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::isOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the connection is open. </p>

<p>Implements <a class="el" href="classio__comm__rx_1_1_manager.html#a4976424aab68662bbd904760a5a354a3">io_comm_rx::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00134">134</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">stream_</a>-&gt;is_open(); }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9cb3f8f003366292da374f48a4a8c74f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">io_comm_rx::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00166">async_manager.hpp:166</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1111154be47a210fa8d22500701f5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1111154be47a210fa8d22500701f5ad">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read_some_handler. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00334">334</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00202">io_comm_rx::AsyncManager&lt; StreamT &gt;::do_read_count_</a>, <a class="el" href="async__manager_8hpp_source.html#l00172">io_comm_rx::AsyncManager&lt; StreamT &gt;::in_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00166">io_comm_rx::AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">stream_</a>-&gt;async_read_some(</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                boost::asio::buffer(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a>.data(),</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">in_</a>.size()),</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                                boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#a3b1fa56a49f408d7d708b447bb356b92">AsyncManager&lt;StreamT&gt;::asyncReadSomeHandler</a>, <span class="keyword">this</span>,</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                                boost::asio::placeholders::error,</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                boost::asio::placeholders::bytes_transferred));</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                                <span class="comment">// The handler is async_read_some_handler, whose call is postponed to </span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                                <span class="comment">// when async_read_some completes.</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">do_read_count_</a> &lt; 5) ++<a class="code" href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">do_read_count_</a>;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a24276a6240a5250a9204a55a659b86ac"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">io_comm_rx::AsyncManager::do_read_count_</a></div><div class="ttdeci">uint16_t do_read_count_</div><div class="ttdoc">Number of times the DoRead() method has been called (only counts initially) </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00202">async_manager.hpp:202</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a3b1fa56a49f408d7d708b447bb356b92"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a3b1fa56a49f408d7d708b447bb356b92">io_comm_rx::AsyncManager::asyncReadSomeHandler</a></div><div class="ttdeci">void asyncReadSomeHandler(const boost::system::error_code &amp;error, std::size_t bytes_transferred)</div><div class="ttdoc">Handler for async_read_some (Boost library).. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00348">async_manager.hpp:348</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a12df1fd87f1b4b00119b0a0b0a2e9fb8"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a12df1fd87f1b4b00119b0a0b0a2e9fb8">io_comm_rx::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdoc">Buffer for async_read_some() to read continuous SBF/NMEA stream. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00172">async_manager.hpp:172</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9cb3f8f003366292da374f48a4a8c74f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">io_comm_rx::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00166">async_manager.hpp:166</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa916a81db2b67c3fc2ff33dc419474df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa916a81db2b67c3fc2ff33dc419474df">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::send </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends commands via the I/O stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>The command to be sent </td></tr>
    <tr><td class="paramname">size</td><td>The size of the command </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classio__comm__rx_1_1_manager.html#a8b506970406c794cf7e457051f45b6c8">io_comm_rx::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00266">266</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    {</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="keywordflow">if</span>(size == 0) </div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            ROS_ERROR(<span class="stringliteral">&quot;Message size to be sent to the Rx would be 0&quot;</span>);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        }</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        </div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        std::vector&lt;uint8_t&gt; vector_temp(cmd.begin(), cmd.end());</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        uint8_t *p = &amp;vector_temp[0];</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        </div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#a01b9a040f84fb4a4e173cc53b85a4a22">AsyncManager&lt;StreamT&gt;::write</a>, <span class="keyword">this</span>, cmd, size));</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a908ef31c7d47b0c7a2ebf0da81bf159f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a908ef31c7d47b0c7a2ebf0da81bf159f">io_comm_rx::AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdoc">io_context object </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00169">async_manager.hpp:169</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a01b9a040f84fb4a4e173cc53b85a4a22"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a01b9a040f84fb4a4e173cc53b85a4a22">io_comm_rx::AsyncManager::write</a></div><div class="ttdeci">void write(std::string cmd, std::size_t size)</div><div class="ttdoc">Sends command &quot;cmd&quot; to the Rx. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00282">async_manager.hpp:282</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="add27deeeb6f3ca46429cb4784ab02965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add27deeeb6f3ca46429cb4784ab02965">&#9670;&nbsp;</a></span>setCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::setCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classio__comm__rx_1_1_manager.html#a029aa66b239f8cee73fcae010ac5c980">Callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback function. </p>

<p>Implements <a class="el" href="classio__comm__rx_1_1_manager.html#a21ce89938f4b4eb1de84335c43d48823">io_comm_rx::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00123">123</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="classio__comm__rx_1_1_manager.html#a8b506970406c794cf7e457051f45b6c8">io_comm_rx::Manager::send()</a>, and <a class="el" href="classio__comm__rx_1_1_manager.html#abd4e49033c12873599ef7484f466ff2d">io_comm_rx::Manager::wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;{ <a class="code" href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">read_callback_</a> = callback; }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_adde94fe262cc75edd105d6df1805f51f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">io_comm_rx::AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdoc">Callback to be called once message arrives. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00184">async_manager.hpp:184</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_add27deeeb6f3ca46429cb4784ab02965_cgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_add27deeeb6f3ca46429cb4784ab02965_cgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_add27deeeb6f3ca46429cb4784ab02965_cgraph" id="classio__comm__rx_1_1_async_manager_add27deeeb6f3ca46429cb4784ab02965_cgraph">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_manager.html#a8b506970406c794cf7e457051f45b6c8" title="Sends commands to the receiver. " alt="" coords="241,5,392,47"/>
<area shape="rect" id="node3" href="classio__comm__rx_1_1_manager.html#abd4e49033c12873599ef7484f466ff2d" title="Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived..." alt="" coords="241,71,392,112"/>
</map>
</div>

</div>
</div>
<a id="a06c366d486f4ef8153406aa5af7c825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c366d486f4ef8153406aa5af7c825a">&#9670;&nbsp;</a></span>tryParsing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::tryParsing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries parsing SBF/NMEA whenever the boolean class variable "try_parsing" is true. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00207">207</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    {</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        uint8_t * to_be_parsed;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        to_be_parsed = <span class="keyword">new</span> uint8_t[<a class="code" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a>];</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <a class="code" href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">to_be_parsed_</a> = to_be_parsed;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordtype">bool</span> timed_out = <span class="keyword">false</span>;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        std::size_t shift_bytes = 0;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        std::size_t arg_for_read_callback = 0;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        </div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keywordflow">while</span>(!timed_out) <span class="comment">// Loop will stop if condition variable timed out</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            boost::mutex::scoped_lock lock(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a39e1c574e60972026401cb9cea9e2b3b">parse_mutex_</a>);</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">parsing_condition_</a>.wait_for(lock, boost::chrono::seconds(10), [<span class="keyword">this</span>](){<span class="keywordflow">return</span> <a class="code" href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">try_parsing_</a>;});</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            <span class="keywordtype">bool</span> timed_out = !<a class="code" href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">try_parsing_</a>;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            <span class="keywordflow">if</span> (timed_out) <span class="keywordflow">break</span>;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">try_parsing_</a> = <span class="keyword">false</span>;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">allow_writing_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            std::size_t current_buffer_size = <a class="code" href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">circular_buffer_</a>.<a class="code" href="class_circular_buffer.html#af91a0d0d6f00a1295612d204998e00bf">size</a>();</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            arg_for_read_callback += current_buffer_size;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">circular_buffer_</a>.<a class="code" href="class_circular_buffer.html#ac0d39c8f590584dbb8e98c320e169c88">read</a>(to_be_parsed + shift_bytes, current_buffer_size);</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            </div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            lock.unlock();</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">parsing_condition_</a>.notify_one();</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            </div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            <span class="keywordflow">try</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                ROS_DEBUG(<span class="stringliteral">&quot;Calling read_callback_() method, with number of bytes to be parsed being %li&quot;</span>, </div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                    arg_for_read_callback);</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">read_callback_</a>(<a class="code" href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">to_be_parsed_</a>, arg_for_read_callback);</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            }</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            <span class="keywordflow">catch</span> (std::size_t&amp; parsing_failed_here) </div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">to_be_parsed_</a> = to_be_parsed + parsing_failed_here;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                ROS_DEBUG(<span class="stringliteral">&quot;Current buffer size is %li and parsing_failed_here is %li&quot;</span>, current_buffer_size, </div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                    parsing_failed_here);</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                arg_for_read_callback = arg_for_read_callback - parsing_failed_here;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                <span class="keywordflow">if</span> (arg_for_read_callback &lt; 0) <span class="comment">// In case some parsing error was not caught, which should never happen..</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                {</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                    <span class="keyword">delete</span> [] to_be_parsed; <span class="comment">// Freeing memory</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                    to_be_parsed = <span class="keyword">new</span> uint8_t[<a class="code" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a>];</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                    <a class="code" href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">to_be_parsed_</a> = to_be_parsed;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                    shift_bytes = 0;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                    arg_for_read_callback = 0;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                }</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                shift_bytes += current_buffer_size;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            }</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            <span class="keyword">delete</span> [] to_be_parsed; <span class="comment">// Freeing memory</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            to_be_parsed = <span class="keyword">new</span> uint8_t[<a class="code" href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">buffer_size_</a>];</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">to_be_parsed_</a> = to_be_parsed;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            shift_bytes = 0;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            arg_for_read_callback = 0;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        }</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        ROS_INFO(<span class="stringliteral">&quot;TryParsing() method finished since it did not receive anything to parse for 10 seconds..&quot;</span>);</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a6b50fd4aa9210ebf0bcbf51686fd7444"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a6b50fd4aa9210ebf0bcbf51686fd7444">io_comm_rx::AsyncManager::buffer_size_</a></div><div class="ttdeci">const std::size_t buffer_size_</div><div class="ttdoc">Size of in_ buffers. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00190">async_manager.hpp:190</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a0dc3ddfac469f0a9e5d36cd5f0e42ba7"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">io_comm_rx::AsyncManager::circular_buffer_</a></div><div class="ttdeci">CircularBuffer circular_buffer_</div><div class="ttdoc">Circular buffer to avoid unsuccessful SBF/NMEA parsing due to incomplete messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00175">async_manager.hpp:175</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a41be2722ecb9acf52af76d2f93fac67e"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a41be2722ecb9acf52af76d2f93fac67e">io_comm_rx::AsyncManager::to_be_parsed_</a></div><div class="ttdeci">uint8_t * to_be_parsed_</div><div class="ttdoc">Memory location where read_callback_ will start reading unless part of SBF/NMEA had to be appended be...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00178">async_manager.hpp:178</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a4bd9a9f61c0bbcd0d388c14a0565a320"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a4bd9a9f61c0bbcd0d388c14a0565a320">io_comm_rx::AsyncManager::parsing_condition_</a></div><div class="ttdeci">boost::condition_variable parsing_condition_</div><div class="ttdoc">Condition variable complementing &quot;parse_mutex&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00163">async_manager.hpp:163</a></div></div>
<div class="ttc" id="class_circular_buffer_html_af91a0d0d6f00a1295612d204998e00bf"><div class="ttname"><a href="class_circular_buffer.html#af91a0d0d6f00a1295612d204998e00bf">CircularBuffer::size</a></div><div class="ttdeci">std::size_t size() const</div><div class="ttdoc">Returns size_. </div><div class="ttdef"><b>Definition:</b> <a href="circular__buffer_8hpp_source.html#l00059">circular_buffer.hpp:59</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_adde94fe262cc75edd105d6df1805f51f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#adde94fe262cc75edd105d6df1805f51f">io_comm_rx::AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdoc">Callback to be called once message arrives. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00184">async_manager.hpp:184</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a240308ada2048ab442fe0f57f57e4563"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a240308ada2048ab442fe0f57f57e4563">io_comm_rx::AsyncManager::allow_writing_</a></div><div class="ttdeci">bool allow_writing_</div><div class="ttdoc">Determines when the asyncReadSomeHandler() method should write SBF/NMEA into the circular buffer...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00160">async_manager.hpp:160</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a39e1c574e60972026401cb9cea9e2b3b"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a39e1c574e60972026401cb9cea9e2b3b">io_comm_rx::AsyncManager::parse_mutex_</a></div><div class="ttdeci">boost::mutex parse_mutex_</div><div class="ttdoc">Mutex to control changes of class variable &quot;try_parsing&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00154">async_manager.hpp:154</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a95fb589f6258bbb2430a32bc3178635a"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a95fb589f6258bbb2430a32bc3178635a">io_comm_rx::AsyncManager::try_parsing_</a></div><div class="ttdeci">bool try_parsing_</div><div class="ttdoc">Determines when the tryParsing() method will attempt parsing SBF/NMEA. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00157">async_manager.hpp:157</a></div></div>
<div class="ttc" id="class_circular_buffer_html_ac0d39c8f590584dbb8e98c320e169c88"><div class="ttname"><a href="class_circular_buffer.html#ac0d39c8f590584dbb8e98c320e169c88">CircularBuffer::read</a></div><div class="ttdeci">std::size_t read(uint8_t *data, std::size_t bytes)</div><div class="ttdoc">Returns number of bytes read. </div><div class="ttdef"><b>Definition:</b> <a href="circular__buffer_8cpp_source.html#l00086">circular_buffer.cpp:86</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_a06c366d486f4ef8153406aa5af7c825a_icgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_a06c366d486f4ef8153406aa5af7c825a_icgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_a06c366d486f4ef8153406aa5af7c825a_icgraph" id="classio__comm__rx_1_1_async_manager_a06c366d486f4ef8153406aa5af7c825a_icgraph">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_async_manager.html#ad06b8889141682af1a6279936326d964" title="Class constructor. " alt="" coords="241,5,429,47"/>
</map>
</div>

</div>
</div>
<a id="a9c2935508cf711725e8cf8b5d79a00a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2935508cf711725e8cf8b5d79a00a7">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived. </p>

<p>Implements <a class="el" href="classio__comm__rx_1_1_manager.html#abd4e49033c12873599ef7484f466ff2d">io_comm_rx::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00389">389</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00181">io_comm_rx::AsyncManager&lt; StreamT &gt;::async_background_thread_</a>, <a class="el" href="async__manager_8hpp_source.html#l00196">io_comm_rx::AsyncManager&lt; StreamT &gt;::count_max_</a>, <a class="el" href="async__manager_8hpp_source.html#l00202">io_comm_rx::AsyncManager&lt; StreamT &gt;::do_read_count_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00193">io_comm_rx::AsyncManager&lt; StreamT &gt;::timer_</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00290">io_comm_rx::AsyncManager&lt; StreamT &gt;::callAsyncWait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    {</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordflow">if</span> (*count &lt; <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">count_max_</a>)</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            ++(*count);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">timer_</a>.expires_at(<a class="code" href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">timer_</a>.expires_at() + boost::posix_time::seconds(1));</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            <span class="keywordflow">if</span> (!(*count == <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">count_max_</a>))</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            {</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">timer_</a>.async_wait(boost::bind(&amp;<a class="code" href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7">AsyncManager::wait</a>, <span class="keyword">this</span>, count));</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            }</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        }</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="keywordflow">if</span> ((*count == <a class="code" href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">count_max_</a>) &amp;&amp; (<a class="code" href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">do_read_count_</a> &lt; 3))</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="comment">// Why 3? Even if there are no incoming messages, read() is called once. </span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        <span class="comment">// It will be called a second time in TCP/IP mode since (just example) &quot;IP10&lt;&quot; is transmitted.</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        {</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            ROS_INFO(<span class="stringliteral">&quot;No incoming messages, driver stopped, ros::spin() will spin forever unless you hit Ctrl+C.&quot;</span>);</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            <a class="code" href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">async_background_thread_</a>-&gt;interrupt(); </div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        }</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a24276a6240a5250a9204a55a659b86ac"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a24276a6240a5250a9204a55a659b86ac">io_comm_rx::AsyncManager::do_read_count_</a></div><div class="ttdeci">uint16_t do_read_count_</div><div class="ttdoc">Number of times the DoRead() method has been called (only counts initially) </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00202">async_manager.hpp:202</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ad7e55c30047a31ca0186a3b3329363db"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ad7e55c30047a31ca0186a3b3329363db">io_comm_rx::AsyncManager::timer_</a></div><div class="ttdeci">boost::asio::deadline_timer timer_</div><div class="ttdoc">Boost timer for throwing ROS_INFO message once timed out due to lack of incoming messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00193">async_manager.hpp:193</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a4659656978af102fc9c3cacc446d4871"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a4659656978af102fc9c3cacc446d4871">io_comm_rx::AsyncManager::count_max_</a></div><div class="ttdeci">const uint16_t count_max_</div><div class="ttdoc">Number of seconds before ROS_INFO message is thrown (if no incoming message) </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00196">async_manager.hpp:196</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_ad51886601f6fd665cac7bdc76fdd6181"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#ad51886601f6fd665cac7bdc76fdd6181">io_comm_rx::AsyncManager::async_background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; async_background_thread_</div><div class="ttdoc">New thread for receiving incoming messages. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00181">async_manager.hpp:181</a></div></div>
<div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9c2935508cf711725e8cf8b5d79a00a7"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9c2935508cf711725e8cf8b5d79a00a7">io_comm_rx::AsyncManager::wait</a></div><div class="ttdeci">void wait(uint16_t *count)</div><div class="ttdoc">Waits count seconds before throwing ROS_INFO message in case no message from the receiver arrived...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00389">async_manager.hpp:389</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__rx_1_1_async_manager_a9c2935508cf711725e8cf8b5d79a00a7_icgraph.png" border="0" usemap="#classio__comm__rx_1_1_async_manager_a9c2935508cf711725e8cf8b5d79a00a7_icgraph" alt=""/></div>
<map name="classio__comm__rx_1_1_async_manager_a9c2935508cf711725e8cf8b5d79a00a7_icgraph" id="classio__comm__rx_1_1_async_manager_a9c2935508cf711725e8cf8b5d79a00a7_icgraph">
<area shape="rect" id="node2" href="classio__comm__rx_1_1_async_manager.html#a74fe4c5680f2e629a6d5b577578dca88" title="Handles the ROS_INFO throwing (if no incoming message) " alt="" coords="241,5,429,47"/>
<area shape="rect" id="node3" href="classio__comm__rx_1_1_async_manager.html#ad06b8889141682af1a6279936326d964" title="Class constructor. " alt="" coords="477,5,665,47"/>
</map>
</div>

</div>
</div>
<a id="a01b9a040f84fb4a4e173cc53b85a4a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b9a040f84fb4a4e173cc53b85a4a22">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends command "cmd" to the Rx. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00282">282</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        boost::asio::write(*<a class="code" href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">stream_</a>, boost::asio::buffer(cmd.data(), size));</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="comment">// Prints the data that was sent</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Sent the following %li bytes to the Rx: \n%s&quot;</span>, size, cmd.c_str());</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    }</div><div class="ttc" id="classio__comm__rx_1_1_async_manager_html_a9cb3f8f003366292da374f48a4a8c74f"><div class="ttname"><a href="classio__comm__rx_1_1_async_manager.html#a9cb3f8f003366292da374f48a4a8c74f">io_comm_rx::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00166">async_manager.hpp:166</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a240308ada2048ab442fe0f57f57e4563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240308ada2048ab442fe0f57f57e4563">&#9670;&nbsp;</a></span>allow_writing_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::allow_writing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines when the <a class="el" href="classio__comm__rx_1_1_async_manager.html#a3b1fa56a49f408d7d708b447bb356b92" title="Handler for async_read_some (Boost library).. ">asyncReadSomeHandler()</a> method should write SBF/NMEA into the circular buffer. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00160">160</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="ad51886601f6fd665cac7bdc76fdd6181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51886601f6fd665cac7bdc76fdd6181">&#9670;&nbsp;</a></span>async_background_thread_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::thread&gt; <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::async_background_thread_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New thread for receiving incoming messages. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00181">181</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00389">io_comm_rx::AsyncManager&lt; StreamT &gt;::wait()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00328">io_comm_rx::AsyncManager&lt; StreamT &gt;::~AsyncManager()</a>.</p>

</div>
</div>
<a id="a6b50fd4aa9210ebf0bcbf51686fd7444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b50fd4aa9210ebf0bcbf51686fd7444">&#9670;&nbsp;</a></span>buffer_size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::buffer_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of in_ buffers. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00190">190</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="a0dc3ddfac469f0a9e5d36cd5f0e42ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc3ddfac469f0a9e5d36cd5f0e42ba7">&#9670;&nbsp;</a></span>circular_buffer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_circular_buffer.html">CircularBuffer</a> <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::circular_buffer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Circular buffer to avoid unsuccessful SBF/NMEA parsing due to incomplete messages. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00175">175</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="a4659656978af102fc9c3cacc446d4871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4659656978af102fc9c3cacc446d4871">&#9670;&nbsp;</a></span>count_max_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::count_max_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of seconds before ROS_INFO message is thrown (if no incoming message) </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00196">196</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00389">io_comm_rx::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="a24276a6240a5250a9204a55a659b86ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24276a6240a5250a9204a55a659b86ac">&#9670;&nbsp;</a></span>do_read_count_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::do_read_count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of times the DoRead() method has been called (only counts initially) </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00202">202</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00334">io_comm_rx::AsyncManager&lt; StreamT &gt;::read()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00389">io_comm_rx::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="a12df1fd87f1b4b00119b0a0b0a2e9fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12df1fd87f1b4b00119b0a0b0a2e9fb8">&#9670;&nbsp;</a></span>in_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::in_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer for async_read_some() to read continuous SBF/NMEA stream. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00172">172</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00334">io_comm_rx::AsyncManager&lt; StreamT &gt;::read()</a>.</p>

</div>
</div>
<a id="a908ef31c7d47b0c7a2ebf0da81bf159f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908ef31c7d47b0c7a2ebf0da81bf159f">&#9670;&nbsp;</a></span>io_service_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::asio::io_service&gt; <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::io_service_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>io_context object </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00169">169</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="a39e1c574e60972026401cb9cea9e2b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e1c574e60972026401cb9cea9e2b3b">&#9670;&nbsp;</a></span>parse_mutex_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::parse_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to control changes of class variable "try_parsing". </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00154">154</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="a4bd9a9f61c0bbcd0d388c14a0565a320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd9a9f61c0bbcd0d388c14a0565a320">&#9670;&nbsp;</a></span>parsing_condition_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::condition_variable <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::parsing_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable complementing "parse_mutex". </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00163">163</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="adde94fe262cc75edd105d6df1805f51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde94fe262cc75edd105d6df1805f51f">&#9670;&nbsp;</a></span>read_callback_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__rx_1_1_manager.html#a029aa66b239f8cee73fcae010ac5c980">Callback</a> <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::read_callback_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback to be called once message arrives. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00184">184</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<a id="a3d850fe28cf7e7c7c7b4b2a48943afc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d850fe28cf7e7c7c7b4b2a48943afc9">&#9670;&nbsp;</a></span>stopping_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::stopping_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not we want to sever the connection to the Rx. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00187">187</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00377">io_comm_rx::AsyncManager&lt; StreamT &gt;::close()</a>.</p>

</div>
</div>
<a id="a9cb3f8f003366292da374f48a4a8c74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb3f8f003366292da374f48a4a8c74f">&#9670;&nbsp;</a></span>stream_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;StreamT&gt; <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::stream_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream, represents either serial or TCP/IP connection. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00166">166</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00296">io_comm_rx::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00377">io_comm_rx::AsyncManager&lt; StreamT &gt;::close()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00334">io_comm_rx::AsyncManager&lt; StreamT &gt;::read()</a>.</p>

</div>
</div>
<a id="ad7e55c30047a31ca0186a3b3329363db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e55c30047a31ca0186a3b3329363db">&#9670;&nbsp;</a></span>timer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::deadline_timer <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::timer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boost timer for throwing ROS_INFO message once timed out due to lack of incoming messages. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00193">193</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00389">io_comm_rx::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="a41be2722ecb9acf52af76d2f93fac67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41be2722ecb9acf52af76d2f93fac67e">&#9670;&nbsp;</a></span>to_be_parsed_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::to_be_parsed_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory location where read_callback_ will start reading unless part of SBF/NMEA had to be appended before. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00178">178</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

</div>
</div>
<a id="a95fb589f6258bbb2430a32bc3178635a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fb589f6258bbb2430a32bc3178635a">&#9670;&nbsp;</a></span>try_parsing_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__rx_1_1_async_manager.html">io_comm_rx::AsyncManager</a>&lt; StreamT &gt;::try_parsing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines when the <a class="el" href="classio__comm__rx_1_1_async_manager.html#a06c366d486f4ef8153406aa5af7c825a" title="Tries parsing SBF/NMEA whenever the boolean class variable &quot;try_parsing&quot; is true. ...">tryParsing()</a> method will attempt parsing SBF/NMEA. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00157">157</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00348">io_comm_rx::AsyncManager&lt; StreamT &gt;::asyncReadSomeHandler()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/septentrio_gnss_driver/communication/<a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 15 2020 10:41:02 for ROSaic by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
